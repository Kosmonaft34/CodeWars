
1.Найдите нечетное число

Дан массив целых чисел, найдите тот, который встречается нечетное количество раз.

Всегда будет только одно целое число, которое встречается нечетное количество раз.

Примеры
[7]должен вернуться 7, потому что это происходит 1 раз (что нечетно).
[0]должен вернуться 0, потому что это происходит 1 раз (что нечетно).
[1,1,2]должен вернуться 2, потому что это происходит 1 раз (что нечетно).
[0,1,0,1,0]должен вернуться 0, потому что это происходит 3 раза (что нечетно).
[1,2,2,3,3,3,4,3,3,3,2,2,1]должен вернуться 4, потому что он появляется 1 раз (что нечетно).

Решение

function findOdd(array){

  let uniqueValue = {}

  for (let number of array){ //перебираем массив
    if(uniqueValue[number] !==undefined) uniqueValue[number]++  //проверяем есть в объекте uniqueValue ключ number и равен ли он числу из массива.Если есть,то увеличиваем на 1
    else uniqueValue[number] = 1 //иначе записываем 1
  }

      let result

  Object.keys(uniqueValue).forEach(key =>{
    if(uniqueValue[key] %2 !==0)
     result = key
  })
  return +result
}

Аналогичный вариант 
for (let key of Object.keys(uniqueValue)){
    if(uniqueValue[key] %2 !==0)
      return +key
  }
____________________________________________________________________________________
2.Friend or Foe?

Создайте программу, которая фильтрует список строк и возвращает список только с именами ваших друзей.

Если в имени ровно 4 буквы, можете быть уверены, что это должен быть ваш друг! В противном случае можете быть уверены, что он не ...

Пример: Input = ["Ryan", "Kieran", "Jason", "Yous"], Output = ["Ryan", "Yous"].

т.е.

друг ["Райан", "Киран", "Марк"] `shouldBe` [" Райан "," Марк "]

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Решение

function friend(friends){
 return friends.filter(friend => friend.length === 4)
}

______________________________________________________________________________________
3.Добро пожаловать.

В этом ката вы должны, учитывая строку, заменить каждую букву ее позицией в алфавите.

Если что-то в тексте не является буквой, игнорируйте это и не возвращайте.

"a" = 1, "b" = 2и т. д.

Пример
alphabetPosition("The sunset sets at twelve o' clock.")
Должен вернуться "20 8 5 19 21 14 19 5 20 19 5 20 19 1 20 20 23 5 12 22 5 15 3 12 15 3 11"(в виде строки)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
решение

function alphabetPosition(text) {
 return text.toLowerCase().split('')
.map(letter =>{
	return letter.charCodeAt(0) - 96
})
.filter(number => {
	return number > 0 && number < 27
})
.join(' ')
}
________________________________________________________________________________________
4.Равные стороны массива

Вам будет дан массив целых чисел. Ваша задача - взять этот массив и найти индекс N, в котором сумма целых чисел слева от N равна сумме целых чисел справа от N. Если нет индекса, который мог бы сделать это, верните -1.

Например:

Допустим, вам дан массив {1,2,3,4,3,2,1}:
ваша функция вернет индекс 3, потому что в 3-й позиции массива сумма левой части index ( {1,2,3}) и сумма правой части index ( {3,2,1}) равны 6.

Посмотрим еще на один.
Вам дан массив {1,100,50,-51,1,1}:
ваша функция вернет индекс 1, потому что в 1-й позиции массива сумма левой части index ( {1}) и сумма правой части index ( {50,-51,1,1}) равны 1.

Последний:
вам дан массив с {20,10,-80,10,10,15,35}
индексом 0, левая сторона - {}
правая сторона. {10,-80,10,10,15,35}
Они оба равны 0при добавлении. (Пустые массивы в этой задаче равны 0)
Индекс 0 - это место, где левая и правая стороны равны.

Примечание: помните, что в большинстве языков программирования / сценариев индекс массива начинается с 0.

Вход:
целочисленный массив длины 0 < arr < 1000. Числа в массиве могут быть любыми целыми положительными или отрицательными.

Выходные данные:
наименьший индекс, в Nкотором сторона слева Nравна стороне справа N. Если вы не найдете индекс, соответствующий этим правилам, вы вернетесь -1.

Примечание.
Если вам дан массив с несколькими ответами, верните наименьший правильный индекс.
++++++++++++++++++++++++++++++++++++++++++++++++++
Решение через forin

function findEvenIndex(arr)
{
  for (let index in arr){
    let leftSum = arr.slice(0,index).reduce((acc, el)=> acc + el, 0)
    let rightSum = arr.slice(+index +1).reduce((acc, el)=> acc + el, 0)
    if (leftSum == rightSum)
      return +index
  }
  return -1
}
+++++++++++++++++++++++++++++++++++++++++++++++++++
Решение через for

function findEvenIndex(arr)
{
  for (let index = 0; index < arr.length; index++){
    let leftSum = arr.slice(0,index).reduce((acc, el)=> acc + el, 0)
    let rightSum = arr.slice(index +1).reduce((acc, el)=> acc + el, 0)
    if (leftSum == rightSum)
      return index
  }
  return -1
}

4.Sum of odd numbers

Учитывая треугольник последовательных нечетных чисел:

             1
            3 5
           7 9 11
        13 15 17 19
      21 23 25 27 29
     ...
Вычислите сумму чисел в n-й строке этого треугольника (начиная с индекса 1), например: (Вход -> Выход)

1 -> 1
2 -> 3 + 5 = 8

+++++++++++++++++++++++++++++++++++++++++++++++++++++++
Решение

let row = 1 //номер строки
function numbersOfTriagle(rowsNumber, numbersInRow = 1, count = 0){ 
    if (rowsNumber === 0) return 0
    if(numbersInRow === rowsNumber) return count + numbersInRow
    return numbersOfTriagle(rowsNumber, numbersInRow + 1, count + numbersInRow)
    return result
}

let nums = numbersOfTriagle(row - 1)
//формула прогрессии
let firstNumNextRow = 1+2 * nums
let result = (2 * firstNumNextRow + 2 *(row - 1)) * row / 2 
console.log(result)